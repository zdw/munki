#!/usr/bin/python
#
# munkiappcast.py
# uses appcast (sparkle) data to build a repository of programs
# that can be updated automatically
#
# Requires an openssl binary to verify signatures on updates. 
#

import sys
import os
import re
import shutil
import optparse
import subprocess
import tempfile
import urllib # for downloading appcasts
from xml.dom import minidom # to parse appcasts

from munkilib import munkicommon
from munkilib import FoundationPlist

def getAppcastInfo(path):
    """
    If available, gets appcast info from the application
    returns a dictionary of the info that was found
    if no appcast info is found, dies. 
    """
    appcastdict = {}

    if not munkicommon.isApplication(path):
        print  >> sys.stderr, ("'%s' is not an application" % path)
        exit(-1)
    else:
        infopath = os.path.join(path, "Contents", "Info.plist")
        plist = FoundationPlist.readPlist(infopath)

        if not 'SUFeedURL' in plist:
            print >> sys.stderr, \
                ("app: '%s' does not appear to be using appcast for updates" % path)
            exit(-1)
        else:
            appcastdict['version'] = plist['CFBundleVersion']

            # if given, use CFBundleName to identify the app, else use appname
            if 'CFBundleName' in plist:
                appcastdict['name'] = plist['CFBundleName']
            else:
                appcastdict['name'] = os.path.basename(path)

            if 'CFBundleShortVersionString' in plist:
                appcastdict['shortversion'] = plist['CFBundleShortVersionString']
            else:
                appcastdict['shortversion'] = plist['CFBundleVersion']

            appcastdict['url'] = plist['SUFeedURL']
            if 'SUPublicDSAKeyFile' in plist:
                appcastdict['dsakey'] = os.path.join(path, "Contents", "Resources", plist['SUPublicDSAKeyFile'])
            else:   
                print >> sys.stderr,  \
                    (" app: '%s' uses appcast but is not DSA signing updates" % path);
                appcastdict['dsakey'] = ''

    return appcastdict


def fetchAppcastFeed(url):
    """ 
    Fetches the appcast RSS feed from the web, parses it, 
    returns information on the topmost update
    """
    appcastfeeddict = {}

    # grab the feed and parse it
    appcastfeed = urllib.urlopen(url).read()
    xmlfeed = minidom.parseString(appcastfeed).documentElement

    # assume that most recent update is the first one
    most_recent = xmlfeed.getElementsByTagName("item")[0]

    enclosure = most_recent.getElementsByTagName("enclosure")[0]

    appcastfeeddict['version'] = enclosure.getAttribute('sparkle:version')

    appcastfeeddict['enclosure_url'] = enclosure.getAttribute('url')
    
    if enclosure.hasAttribute('sparkle:dsaSignature'):
        appcastfeeddict['dsasig'] = enclosure.getAttribute('sparkle:dsaSignature')
    else:
        appcastfeeddict['dsasig'] = False

    if enclosure.hasAttribute('sparkle:shortVersionString'):
         appcastfeeddict['shortversion'] = \
                 enclosure.getAttribute('sparkle:shortVersionString')
    else:
        appcastfeeddict['shortversion'] = appcastfeeddict['version']

    return appcastfeeddict


def storeAppcastInfo(configpath, appcast):
    """ store the information for the given Appcast in the appcast repo folder """ 
    
    appconfigpath = os.path.join(configpath,appcast['name'])
    appdmgpath = os.path.join(appconfigpath,"dmgs")

    if not os.path.isdir(appconfigpath):
        os.mkdir(appconfigpath)
    else:
        print >> sys.stderr, \
            ("the application %s already has been added at %s" % (appcast['name'], appconfigpath))
        exit(-1)

    if not os.path.isdir(appdmgpath):
        os.mkdir(appdmgpath)

    # write the feed url into the file
    feedurlpath = os.path.join(appconfigpath,'url')
    feedurlfile = open(feedurlpath, 'w')
    feedurlfile.write(appcast['url'])
    feedurlfile.close()

    # copy the dsa key, if it exists, into the appconfigpath
    if not appcast['dsakey'] == '':
        dsakeydestpath = os.path.join(appconfigpath,'dsakey')
        shutil.copyfile(appcast['dsakey'], dsakeydestpath)


def urlRetrieveReportHook(transferred, blocksize, totalsize):
    """ hook called by urlretrieve in fetchAppcastFileEnclosure """

    print "tranferred %d blocks, total size: %d" % (transferred, totalsize)
    

def fetchAppcastFileEnclosure(url):
    """
    fetches the file specified at the URL, returns a path to the file
    """

    try:
        filename = urllib.urlretrieve(url, '' , urlRetrieveReportHook)[0]
    except IOError, e:
        print >> sys.stderr, \
                "error retrieving download: %s" % e.code
        filename = False

    return filename


def checkDSAsig(signature, keypath, filepath):
    """ checks the validitity of the downloaded file with the appcast DSA key """

    # this is the reverse of how the signature is generated, as specified here:
    # https://github.com/andymatuschak/Sparkle/blob/master/sign_update.rb

    openssl = '/usr/bin/openssl'

    # OpenSSL only will process input if it ends with a newline
    sig_openssl = "%s\n" % signature 

    # get a temp file for storing the binary version of the hash
    bin_sig_file = tempfile.NamedTemporaryFile().name

    # equivalent shell command (using MarsEdit 3.2 as a test)
    # echo "MCwCFH0m2lXraXE36vqcx+JxrovmDV/EAhQ2+v25wj++PSJWRn/5DQtkqKDPpg==" | openssl enc -d -base64 -out sha1.bin

    base64_to_bin_cmd = [ openssl, 'enc', '-d', '-base64',  '-out', bin_sig_file ]
    
    proc_b64tobin = subprocess.Popen(base64_to_bin_cmd, stdin=subprocess.PIPE)
    proc_b64tobin.communicate(input=sig_openssl)

    # openssl dgst -sha1 -binary  MarsEdit3.2.zip | openssl dgst -dss1 -verify RedSweaterUpdatesPublicKey.pem -signature sha1.bin 
    # correct return: Verified OK

    dgst1_cmd = [ openssl, 'dgst', '-sha1', '-binary', filepath ]
    dgst2_cmd = [ openssl, 'dgst', '-dss1', '-verify', keypath, '-signature', bin_sig_file]
    
    proc_dgst1 = subprocess.Popen(dgst1_cmd, stdout=subprocess.PIPE)
    proc_dgst2 = subprocess.Popen(dgst2_cmd, stdin=proc_dgst1.stdout, stdout=subprocess.PIPE)
    proc_dgst1.stdout.close()
    verify_out = proc_dgst2.communicate()[0]

    print " DSA signature check: %s" % verify_out.rstrip() # strip the newline

    if verify_out == "Verified OK\n":
        return True
    return False


def moveAndConvert(filepath, destpath):
    """ given the application in one of sparkle's supported formats, save it into a dmg file """

    """ Per the sparkle website, the file can be in a .dmg, .zip, .tar.gz, or .tar.bz 
        https://github.com/andymatuschak/Sparkle/wiki/publishing-an-update """

    dmgname = os.path.splitext(os.path.basename(destpath))[0]
    extension = os.path.splitext(filepath)[1]

    if extension == ".dmg":
        print " download is a .dmg, recompressing to %s" % destpath
        hdiutilcmd = ['/usr/bin/hdiutil', 'convert', filepath, '-format', 'UDBZ', '-o', destpath]
        proc_hdiutil = subprocess.Popen(hdiutilcmd)
        proc_hdiutil.wait()
        return
    else:
        # make a temporary directory with the name of the final dmg
        dmgtempdir = os.path.join(tempfile.mkdtemp(),dmgname)
        os.mkdir(dmgtempdir)
        
        if extension == ".zip":
            print " download is a .zip, recompressing to .dmg"
            unarchivecmd = ['/usr/bin/unzip',filepath, '-d', dmgtempdir]
        elif extension == ".tgz" or extension == ".gz":
            print " download is a .tar.gz, recompressing to .dmg"
            unarchivecmd = ['/usr/bin/tar', '-xzf', filepath, '-C', dmgtempdir, '--strip-components', '1']
        elif extension == ".tbz" or extension == ".tbz2" or extension == ".bz" or extension == ".bz2":
            print " download is a .tar.bz2, recompressing to .dmg"
            unarchivecmd = ['/usr/bin/tar', '-xjf', filepath, '-C', dmgtempdir, '--strip-components', '1']
        else:
            print " download is in an unknown file format, exiting"
            exit(-1)

        proc_unarch = subprocess.Popen(unarchivecmd)
        
        if proc_unarch.wait():
            print >> sys.stderr, \
                    "error in uncompressing download"
            exit(-1)
        else:
            hdiutilcmd =  ['/usr/bin/hdiutil', 'create', '-format', 'UDBZ', '-srcfolder', dmgtempdir, destpath]
            proc_hdiutil = subprocess.Popen(hdiutilcmd)
            proc_hdiutil.wait()


def main():
    """ main function """

    usage = """usage: %prog [options] [/path/to/application]
        Creates or maintains a repository of appcasts for use with munki"""

    p = optparse.OptionParser(usage)

    p.add_option('-a', '--app',
            action='store', 
            type='string',
            dest='appname',
            help="""Add the appcast of the application to the configuration directory""")

    p.add_option('-u', '--update', 
            action='store_true',
            help="""Search for updates for appcasts""")

    p.add_option('-d', '--download',
            action='store_true',
            help="""If updates are found, download them. Requires updates""")

    p.add_option('-m', '--munkiimport',
            action='store_true',
            help="""run munkiimport on the downloaded files""")

    p.add_option('-c', '--configdir',
            action='store',
            default='~/.munkiappcast',
            help="""use this configuration directory for storing appcast data - default is ~/.munkiappcast""")

    (opts, args) = p.parse_args()
    
    configpath = os.path.expanduser(opts.configdir) # do tilde expansion on config dir
    
    if not os.path.isdir(configpath):
        print >> sys.stderr, \
            ("config dir %s does not exist, or isn't a directory" % configpath)
        exit(-1)

    if opts.download and not opts.update:
        print >> sys.stderr, \
            ("You must update in order to download\n")
        p.print_help()
        exit(-1)

    if opts.appname:
    
        appcast = getAppcastInfo(opts.appname)

        print "Added app: %s\n Feed url: %s" % (opts.appname, appcast['url'])

        storeAppcastInfo(configpath, appcast)

        exit(0) 

    if opts.update:

        for appinfodir in os.listdir(configpath):
            print "Updating: %s" % appinfodir
            appcasturl = open(os.path.join(configpath,appinfodir, 'url')).read()

            feed = fetchAppcastFeed(appcasturl)

            storedversionpath = os.path.join(configpath,appinfodir,'version')

            if os.path.isfile(storedversionpath):
                fd_version = open(storedversionpath, 'r')
                storedversion = fd_version.read()
                fd_version.close()
            else:
                storedversion = 0

            if feed['version'] > storedversion:
                print " new version found: %s, aka %s" % (feed['version'], feed['shortversion'])
            else:
                print " version %s is current" % feed['version']
                continue

            if opts.download:

                print " downloading update %s" % feed['enclosure_url']
                enclosure = fetchAppcastFileEnclosure(feed['enclosure_url'])
                print " fetched update to temp file: %s" % enclosure

                if enclosure and feed['dsasig']:
                    dsakeypath = os.path.join(configpath,appinfodir,'dsakey')
                    if os.path.isfile(dsakeypath):
                        dsavalid = checkDSAsig(feed['dsasig'], dsakeypath , enclosure)
                        if not dsavalid:
                            print ' DSA Signature invalid on downloaded update'
                            continue
                    else:
                        print ' DSA Key not found, but signature in appcast'

                # build a consistent name for the update
                updatedmgname = re.sub(r'\s',"_",appinfodir) + "-" + feed['shortversion'] + ".dmg"
                print " converting and saving to: %s" % updatedmgname

                appdmgpath = os.path.join(configpath,appinfodir,'dmgs',updatedmgname)

                moveAndConvert(enclosure, appdmgpath)

                # update version on disk
                fd_version = open(storedversionpath,'w')
                fd_version.write(feed['version'])
                fd_version.close();

    exit(0)


if __name__ == '__main__':
    main()

